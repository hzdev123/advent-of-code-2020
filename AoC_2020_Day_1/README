Table of contents

    1. Task Description
    2. Summary
        2.1 Day-1-1
        2.2 Day-1-2
    3. Example
        3.1 Day-1-1
        3.2 Day-1-2
    4. Run the program
    5. Run the tests
    6. Discussion
        6.1 Day 1-1 - 2D
        6.2 Day 1-2 - 3D
    7. Future improvements:


1. Task Description
    https://adventofcode.com/2020/day/1

2. Summary
    2.1 Day-1-1
        Given a list of integers:
            Return the product of two list entries that sum up to 2020.

            A + B = 2020
            A * B = ???

            Ans: ???

    2.2 Day-1-2
        Given a list of integers:
            Return the product of three list entries that sum up to 2020.

            A + B + C = 2020
            A * B * C = ???

            Ans: ???

3. Example
    3.1 Day-1-1
        1721
        979
        366
        299
        675
        1456

        1721 + 299 = 2020
        1721 * 299 = 514579

        Ans: 514579

    3.2 Day-1-2
        1721
        979
        366
        299
        675
        1456

        979 + 366 + 675 = 2020
        979 * 366 * 675 = 241861950

4. Run the program
    cd AoC_2020_Day_1
    make run

5. Run the tests
    cd AoC_2020_Day_1
    make test

6. Discussion
    cd AoC_2020_Day_1
    make compare
        to see a graph which compares the brute force approach with position tracking approach.

    6.1 Day 1-1 - 2D
        Given the example list:
            [1721 979 366 299 675 1456]

        To find two integers whose sum is 2020 we do the below.

             2020    2020    2020    2020    2020    2020     <--- sum
            -1721   - 979   - 366   - 299   - 675   -1456     <--- list entries
            -----   -----   -----   -----   -----   -----
              299    1041    1654    1721    1345     564     <--- complement

        And store the complement as the map's key.

        Iterating the list and creating the map takes O(n).
        Accessing element from the map is O(1).

        For every list entry in the example list, we check if it is in the map.

        If it is, then:
            (2020 - list entry) + list entry = 2020

        In our example:
            (2020 - 1721) + 1721 = 299 + 1721 = 2020
            Both 299 and 1721 is in the example list

        Iterating the list is O(n).1

        So total time complexity is: O(n) + O(1) + O(n) =
            O(n)

        The trivial solution of comparing all list entries with eachother is:
            O(n^2)

        6.2 Day 1-2 - 3D
            1
            x
            y
            ---             0                       n=1
            x

            12
            x2
            yy
            ---             0 + 0                   n=2
            x


            123
            x23
            yy3
            ---             1 + 0 + 0               n=3
            123

            1234
            x234
            yy34
            -----
            123 124         3 + 1 + 0 + 0           n=4
            134

            234

            12345
            x2345
            yy345
            -----           6 + 3 + 1 + 0 + 0       n=5
            123 124 125
            134 135
            145

            234 235
            245

            345


            123456
            x23456
            yy3456
            ------          10 + 6 + 3 + 1 + 0 + 0  n=6
            123 124 125 126
            134 135 136
            145 146
            156

            234 235 236
            245 246
            256

            345 346
            356

            456

            based on the above examples the below conclusions are drawn:

                Number of operations for worst case scenario:

                    Compare every list element with eachother:
                        f(n) = n^3
                    USe Position Tracking to avoid duplicated operations:
                        f(n) = sum(range(1, n - 1)) + previous sums

                    1 is used in range instead of 0 because 0 does not add anything.

7. Future improvements

    An improvement could be:
        first sort the list entries from lowest to highest
        find a pivot element
        from the pivot element
            compare the list entries A and B:
                A: lowest to pivot element
                B: pivot element to highest
